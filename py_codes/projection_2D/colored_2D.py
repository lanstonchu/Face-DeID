# Author: Lanston Hau Man Chu
# 2021.06.01

# input list: myList.txt; format in the pairs of (initial, pb/pre-pb final frontal, rotation, out_color, out_resized, out_2D) with no space between the pairs
# this file will transfer color from the original 6-column .ply to the final frontal 3-columns .ply
# the .ply files are generated by C++
# the 2D output images will be generated in the same folder of the input of 3D .ply

import numpy as np
import os
from plyfile import PlyData, PlyElement
from scipy import spatial
from scipy import stats
import matplotlib.pyplot as plt
import time
from rotate_resize_3D import rotate_resize_1_plydata, random_rot_vector

# to convert retangular coordinates to spherical coordinates
def reg_to_sph(reg_coord):

    # theory: https://en.wikipedia.org/wiki/Spherical_coordinate_system
    # format modification: elevation angle is from y-axis: https://threejs.org/docs/#api/en/math/Spherical
    x = reg_coord[:,0]
    y = reg_coord[:,1]
    z = reg_coord[:,2]

    r_xz_square = x**2 + z**2 # for atan2
    r = np.sqrt(r_xz_square + y**2)

    thetas_vec = np.arctan2(np.sqrt(r_xz_square), y) % np.pi # elevation angle from y-axis; belongs to [0, pi)
    phis_vec = (np.arctan2(-z, x) - np.pi/2) % (2*np.pi)

    sph_coord = np.transpose(np.vstack((r, thetas_vec, phis_vec))) # (r, elevation, angle_xy)

    thetas = sph_coord[:,1] # same as reformatting thetas_vec
    phis = sph_coord[:,2]

    return sph_coord, thetas, phis

# plot the histogram of (phi, theta) pairs (i.e. vertices)
def plot_histogram_scatter(phis, thetas, phi_min, phi_max, theta_min, theta_max, bin_num):
    fig, ax = plt.subplots()
    plt.hist2d(phis, thetas, bins=[bin_num, bin_num], range = [[phi_min, phi_max], [theta_min, theta_max]],cmap='Blues')
    ax.set_title('Histogram')
    ax.set_xlabel(r"$\phi$")
    ax.set_ylabel(r"$\theta$")

    plt.xlim(phi_min, phi_max)
    plt.ylim(theta_min, theta_max)

    ax.invert_yaxis()

    plt.show()
    return

# computer the average color of (phi, theta) retangular-bins based on the vertices inside bins
def compute_average_color(color, bin_points, stat2D):
    # input:
    #   color: color of vertices; size num_vertices x 3
    #   bin_points: bin-index of vertices; size num_vertices x 2
    #   stat2D: number of vertices in each bins; size bin_num x bin_num
    # output:
    #   average color of bins; size bin_num x bin_num x 3, in integers

    if np.shape(color)[0]!=np.shape(bin_points)[0]:
        raise Exception("The numbers of vertices don't match.")

    if np.shape(stat2D)[0]!=np.shape(stat2D)[1]:
        raise Exception("stat2D should be a square array.")

    num_vertices, _ = np.shape(color)
    bin_num, _ = np.shape(stat2D)

    bin_color_sum = np.zeros([bin_num, bin_num, 3]) # 3 channels for color RGB
    bin_color_avg = np.zeros([bin_num, bin_num, 3], dtype="int") # integral color to match format of .ply
    for i in range(num_vertices):
        bin_index_i = bin_points[i]
        color_i = color[i]

        theta_bin = bin_index_i[0] # angles' values extraction
        phi_bin = bin_index_i[1]

        bin_color_sum[theta_bin - 1, phi_bin - 1] += color_i

    for j in range(bin_num):
        for k in range(bin_num):

            if np.all(bin_color_sum[j, k]!=[0, 0, 0]) and (stat2D[j,k]==0):
                raise Exception("stat2D shouldn't be zero if the color-sum is non-zero.")

            if stat2D[j,k]==0: # i.e. no vertice in bin
                bin_color_avg[j,k] = [0, 0, 0]
            else: # i.e. some vertices in bin
                bin_color_avg[j,k] = np.round(bin_color_sum[j,k]/stat2D[j,k])

    return bin_color_avg

# this function will do spherical histogram on the 6-columns plydata, and then output average colors
def stats_ply_color(plydata, bin_num):

    vertices = plydata.elements[0] # 0 for vertices; 1 for faces

    vertices_values = np.array([list(vertix_values) for vertix_values in vertices.data]) # re-format vertices' coordinates/color as array
    num_vertices, num_columns = np.shape(vertices_values)

    if num_columns !=6:
        raise Exception("3 shape columns and 3 color columns should be included in the .ply file")

    shape = vertices_values[:,0:3]
    color = vertices_values[:,3:6]

    # shape_on_unit_sphere = np.apply_along_axis(becomes_unit_vector, 1, shape) # projecting shape on unit sphere

    _, thetas, phis = reg_to_sph(shape)

    theta_max = np.max(thetas)
    theta_min = np.min(thetas)

    phi_max = np.max(phis)
    phi_min = np.min(phis)

    edges_theta = np.linspace(theta_min, theta_max, num=bin_num+1) # i.e. #(edges required) = #(bins) + 1
    edges_phi = np.linspace(phi_min, phi_max, num=bin_num+1)

    binStat2D = stats.binned_statistic_2d(thetas, phis, None, 'count', bins=[edges_theta, edges_phi], expand_binnumbers=True)

    stat2D = binStat2D.statistic # number of vertices in each bins
    bin_points = np.transpose(binStat2D.binnumber) # bin-index of each vertices

    # some analysis and checking
    # plot_histogram_scatter(phis, thetas, phi_min, phi_max, theta_min, theta_max, bin_num) # scatter plot reflects a human face
    ## counts, bins = np.histogram(stat2D)
    ## plt.hist(bins[:-1], bins, weights=counts)

    bin_color_avg = compute_average_color(color, bin_points, stat2D)

    return bin_color_avg, edges_theta, edges_phi

# find the s and t (i.e. location proportion in bin) and bin-indices of vertices
def find_st_values(thetas_pre_crop, phis_pre_crop, theta_max, theta_min, phi_max, phi_min, bin_num):
    # thetas_pre_crop and phis_pre_crop: thetas and phis of vertices; 2 vectors
    # thetas_pre_crop can be larger than theta_max and/or smaller than theta_min; similar for phi.
    # theta_max, theta_min, phi_max, phi_min: the bins' boundaries; 4 scalars

    if theta_max < theta_min or phi_max < phi_min:
        raise Exception("Max. shouldn't be smaller than Min.")

    delta_theta = (theta_max - theta_min)/bin_num
    delta_phi = (phi_max - phi_min)/bin_num

    # crop data by using max/min values
    thetas = np.minimum(np.maximum(thetas_pre_crop, theta_min), theta_max)
    phis = np.minimum(np.maximum(phis_pre_crop, phi_min), phi_max)

    percent_thetas, bin_indice_minus_1_thetas = np.modf((thetas - theta_min)/delta_theta)
    percent_phis, bin_indice_minus_1_phis = np.modf((phis- phi_min)/delta_phi)

    percent_thetas_shift, _ = np.modf(percent_thetas + 0.5)
    percent_phis_shift, _ = np.modf(percent_phis + 0.5)

    return percent_thetas_shift, percent_phis_shift, bin_indice_minus_1_thetas, bin_indice_minus_1_phis

# get color for new vertices by bins lookup; alternative of color_assignment_interpolate()
def color_assignment_direct(thetas, phis, edges_theta, edges_phi, bin_color_avg):
    # thetas, phis: values of new vertices
    # edges_theta, edges_phi: bins' edges determined by the old vertices

    if np.shape(thetas)[0] != np.shape(phis)[0]:
        raise Exception("Number of vertices don't match.")

    if np.shape(edges_theta)[0] != np.shape(edges_phi)[0]:
        raise Exception("#(theta bins) and #(phi bins) don't match.")

    num_vertices = np.shape(thetas)[0]

    binStat2D = stats.binned_statistic_2d(thetas, phis, None, 'count', bins=[edges_theta, edges_phi], expand_binnumbers=True)
    # stat2D = binStat2D.statistic # number of vertices in each bins
    bin_points = np.transpose(binStat2D.binnumber) # bin-index of each vertices

    color_final = np.zeros([num_vertices, 3])
    for i in range(num_vertices):

    # angles' values extraction
        bin_index_i = bin_points[i]
        theta_bin = np.min([bin_num, np.max([1, bin_index_i[0]])]) # restrict [0, bin_num + 1] into [1, bin_num], i.e. assign over-the-boundaries indices to the boundaries
        phi_bin = np.min([bin_num, np.max([1, bin_index_i[1]])])

        color_final_i = bin_color_avg[theta_bin - 1, phi_bin - 1] # look up the region's color
        color_final[i] = color_final_i # stored the looked up color

    return color_final

# get color for new vertices by bins interpolation; alternative of color_assignment_direct()
def color_assignment_interpolate(thetas, phis, edges_theta, edges_phi, bin_color_avg):
    # thetas, phis: values of new vertices
    # edges_theta, edges_phi: bins' edges determined by the old vertices

    if np.shape(thetas)[0] != np.shape(phis)[0]:
        raise Exception("Number of vertices don't match.")

    if np.shape(edges_theta)[0] != np.shape(edges_phi)[0]:
        raise Exception("#(theta bins) and #(phi bins) don't match.")

    num_vertices = np.shape(thetas)[0]
    bin_num = np.shape(edges_theta)[0] - 1

    theta_max = edges_theta[-1] # the max. values of the original .ply, not final frontal .ply
    theta_min = edges_theta[0]

    phi_max = edges_phi[-1]
    phi_min = edges_phi[0]

    percent_thetas_shift, percent_phis_shift, bin_indice_minus_1_thetas, bin_indice_minus_1_phis \
    = find_st_values(thetas, phis, theta_max, theta_min, phi_max, phi_min, bin_num)

    color_final = np.zeros([num_vertices, 3])
    for i in range(num_vertices):

        t = percent_thetas_shift[i]
        s = percent_phis_shift[i]
        cen_th = bin_indice_minus_1_thetas[i] # i.e. center
        cen_ph = bin_indice_minus_1_phis[i]

        ratios = np.array([t/2 - s*t/4, s*t/4, 1 - s/2 - t/2 + s*t/4, s/2 - s*t/4]) # i.e. [TL, TR, BL, BR]

        if t > 0.5 and s <= 0.5: # top left
            # i.e. center + right + bottom + bottom right
            positions = np.array([[cen_th, cen_ph], [cen_th, cen_ph + 1], [cen_th + 1, cen_ph], [cen_th + 1, cen_ph + 1]])

        elif t > 0.5 and s > 0.5: # top right
            # i.e. left + center + bottom left + bottom
            positions = np.array([[cen_th, cen_ph - 1], [cen_th, cen_ph], [cen_th + 1, cen_ph - 1], [cen_th + 1, cen_ph]])

        elif t <= 0.5 and s <= 0.5: # bottom left
            # i.e. top + top right + center + right
            positions = np.array([[cen_th - 1, cen_ph], [cen_th - 1, cen_ph + 1], [cen_th, cen_ph], [cen_th, cen_ph + 1]])

        elif t <= 0.5 and s > 0.5: # bottom right
            # i.e. top left + top + left + center
            positions = np.array([[cen_th - 1, cen_ph - 1], [cen_th - 1, cen_ph], [cen_th, cen_ph - 1], [cen_th, cen_ph]])

        else:
            raise Exception("Shouldn't reach this line.")

        positions = np.minimum(np.maximum(positions, [0, 0]), [bin_num - 1, bin_num - 1]) # cropping index to avoid error

        color_final_i = np.zeros(3) # for RGB
        for j in range(4):
            ratio = ratios[j]
            posi = positions[j]

            color_final_i += ratio*bin_color_avg[int(posi[0]), int(posi[1])] # look up the region's color
        color_final[i] = color_final_i # stored the looked up color

    return color_final

# this function will add color to the 3-columns plydata
def add_ply_color(plydata, edges_theta, edges_phi, bin_color_avg, color_interpolate_flag):

    vertices = plydata.elements[0] # 0 for vertices; 1 for faces

    vertices_values = np.array([list(vertix_values) for vertix_values in vertices.data]) # re-format vertices' coordinates/color as array
    num_vertices, num_columns = np.shape(vertices_values)

    if num_columns !=3: # .ply shouldn't include the RGB color
        raise Exception("The .ply file should only contains 3 shape columns.")

    shape_final = vertices_values[:,0:3]

    if np.isnan(np.sum(shape_final)): # if NaN value is contained in the coordinates of the final frontal .ply
        NaN_Error = 1 # failed to complete the function due to NaN value(s)
        return "", NaN_Error

    _, thetas_final, phis_final = reg_to_sph(shape_final)

    if color_interpolate_flag == 0:
        color_final = color_assignment_direct(thetas_final, phis_final, edges_theta, edges_phi, bin_color_avg)
    elif color_interpolate_flag == 1:
        color_final = color_assignment_interpolate(thetas_final, phis_final, edges_theta, edges_phi, bin_color_avg)
    else:
        raise Exception("Shouldn't reach this line.")

    # some analysis and checking
    # bin_num = np.shape(edges_theta)[0] - 1
    # plot_histogram_scatter(phis_final, thetas_final, edges_phi[0], edges_phi[-1], edges_theta[0], edges_theta[-1], bin_num) # scatter plot reflects a human face

    NaN_Error = 0
    return color_final, NaN_Error

def generate_1_final_color_shape(full_file_path_initial, full_file_path_final, bin_num, plyTextFlag, color_interpolate_flag):

    ### Part I: color transferral ###

    # can be hidden when debug to allow shorter running time, if only run 1 file
    plydata_initial = PlyData.read(full_file_path_initial)
    plydata_final = PlyData.read(full_file_path_final)

    bin_color_avg, edges_theta, edges_phi = stats_ply_color(plydata_initial, bin_num) # extract color from the original .ply

    color_final, NaN_Error = add_ply_color(plydata_final, edges_theta, edges_phi, bin_color_avg, color_interpolate_flag) # add the extracted color to the final frontal .ply (with different #(vertices))

    if NaN_Error == 1: # if there is NaN in the final frontal .ply
        return "", NaN_Error

    ### Part II: save .ply file ###

    vertices_xyz_final = plydata_final.elements[0].data

    vertices_xyzrgb_final = np.array([(np.round(xyz[0],4), np.round(xyz[1],4), np.round(xyz[2],4), rgb[0], rgb[1], rgb[2]) for \
                        xyz, rgb in zip(vertices_xyz_final, color_final)], \
                        dtype=[('x', 'f4'), ('y', 'f4'),('z', 'f4'), ('red','u1'), ('green','u1'), ('blue','u1')])
    element_vertices = PlyElement.describe(vertices_xyzrgb_final, 'vertex')
    element_faces = plydata_final.elements[1]

    plydata_final_colored = PlyData([element_vertices, element_faces], text=plyTextFlag)

    return plydata_final_colored, NaN_Error

tic = time.perf_counter() # count the running time

PLYsListPath = "./inputList_180_normal_smile.txt" # input/ouput list; format in the pairs of 6 lines for each group
logPath = "./log.txt" # log path for tempary record purpose

bin_num = 100
plyTextFlag = False # whether save the output .ply as text, or binary
color_interpolate_flag = 1 # option to get color directly from bin (i.e. 0), or to do interpolation (i.e. 1)

image_size = [450, 450] # width and height
remove_PLY_flag = 1

with open(PLYsListPath, "r") as f, open(logPath, "w") as myLog:

    lines = f.readlines()
    count_group = 0 # 1 group for 6 lines
    count_within_group = 0 # count lines within a group, i.e. 0, 1, 2, 0, 1, 2, 0, 1, 2, ...
    for line in lines:
        line_trimmed = line.strip() # remove the spaces/"\n" etc. from the string

        if line_trimmed=="":
            if count_within_group != 0: # empty line is not allowed for 2nd/3rd files of the group
                raise Exception("Shouldn't have space between the 1st line and the 2nd line.")
            else: # skip empty line for the 1st file
                continue
        elif line_trimmed[0]=="#": # skip comment line
            continue

        # Line 0: to obtain the initial .ply (i.e. input)
        if count_within_group == 0:
            full_file_path_initial = line_trimmed
            count_within_group += 1

        # Line 1: to obtain the final .ply (i.e. input)
        elif count_within_group == 1:
            full_file_path_final = line_trimmed
            count_within_group += 1

        # Line 2: to obtain the rotation vector (i.e. input)
        elif count_within_group == 2:

            if line_trimmed == "-": # not providing rotation vector in .txt, and will use random vector
                rVec = random_rot_vector()
            else:
                rVecList = [float(value) for value in line_trimmed.split()]
                if len(rVecList)!=3:
                    raise Exception("Length of rotation vector should be 3.")
                rVec = np.array(rVecList).reshape((3,1))
                count_within_group += 1

        # Line 3: path for colored final .ply (i.e. output)
        elif count_within_group == 3:
            output_path_color_final = line_trimmed
            count_within_group += 1

        # Line 4: path for rotated/resized .ply (i.e. output)
        elif count_within_group == 4:
            rotated_resized_path = line_trimmed

            if rotated_resized_path == "-":
                raise Exception("The path of rotated/resized .ply cannot be skipped.")
            count_within_group += 1

        # Line 5: path for 2D image
        elif count_within_group == 5:
            image_2D_path = line_trimmed

            if image_2D_path == "-":
                raise Exception("The 2D image path cannot be skipped.")

            # get the final color shape by using the two .ply files
            toc = time.perf_counter() # running time counted
            print("Count = " + str(count_group) + "; File: " + rotated_resized_path + f"; Start time: {toc - tic:0.1f} seconds")
            plydata_final_colored, NaN_Error = generate_1_final_color_shape(full_file_path_initial, full_file_path_final, bin_num, plyTextFlag, color_interpolate_flag)

            if NaN_Error == 0: # if there are no NaN values in final .ply
                if output_path_color_final=="-":
                    plydata_final_colored.write(output_path_color_final) # save the colored final 3D shape as .ply file

                rotate_resize_1_plydata(plydata_final_colored, rotated_resized_path, image_2D_path, image_size, rVec, remove_PLY_flag)
            elif NaN_Error == 1: # if there are NaN values in final .ply
                print("\n NaN Error at " + full_file_path_final + "\n")
                myLog.write("NaN Error at " + full_file_path_final + "\n")

            count_within_group = 0 # next line would be the initial .ply
            count_group += 1
        else:
            raise Exception("Shouldn't reach this line.")
